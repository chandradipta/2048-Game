<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>2048 Game</title>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex; justify-content: center; align-items: center;
    height: 100vh; margin: 0;
    background: #faf8ef;
    transition: background 0.3s, color 0.3s;
  }
  body.dark { background: #121212; color: #eee; }
  .game-container { text-align: center; position: relative; }
  .score-container {
    display: flex; justify-content: center; gap: 20px; margin-bottom: 10px;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(4, 100px);
    grid-gap: 10px;
    background: #bbada0; padding: 10px;
    border-radius: 10px;
    margin: auto;
    position: relative;
  }
  .tile {
    width: 100px; height: 100px;
    display: flex; justify-content: center; align-items: center;
    background: #cdc1b4;
    border-radius: 5px;
    font-size: 24px; font-weight: bold;
    transition: all 0.2s;
  }
  .tile.new { animation: pop 0.3s; }
  .tile.merge { animation: bump 0.2s; }
  @keyframes pop { from {transform: scale(0);} to {transform: scale(1);} }
  @keyframes bump { 50% {transform: scale(1.2);} }
  .controls button {
    margin: 5px; padding: 10px 15px;
    border: none; border-radius: 5px;
    background: #8f7a66; color: white;
    cursor: pointer; font-size: 14px;
    transition: background 0.2s;
  }
  .controls button:hover { background: #a08c75; }
  body.dark .controls button { background: #333; }
  .overlay {
    position: absolute; top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.7);
    display: flex; justify-content: center; align-items: center;
    flex-direction: column;
    font-size: 28px; font-weight: bold;
    color: white; border-radius: 10px;
    display: none;
  }
  .overlay button {
    margin-top: 20px;
    background: #edc22e; color:#333; font-weight:bold;
  }
</style>
</head>
<body>
<div class="game-container">
  <h1>2048</h1>
  <div class="score-container">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="controls">
    <button onclick="newGame()">New Game</button>
    <button onclick="undo()">Undo</button>
    <button onclick="autoPlay()">AI Autoplay</button>
    <button onclick="resetBest()">Reset Best</button>
    <button onclick="toggleDark()">Toggle Dark Mode</button>
  </div>
  <div class="grid" id="grid"></div>
  <div class="overlay" id="overlay">
    <div id="overlay-text"></div>
    <button onclick="hideOverlay();">Continue</button>
  </div>
</div>

<script>
const gridSize = 4;
let board, score = 0, best = 0, history = [], autoplay = false, dark=false;
const colors = {
  0:"#cdc1b4",2:"#eee4da",4:"#ede0c8",8:"#f2b179",16:"#f59563",
  32:"#f67c5f",64:"#f65e3b",128:"#edcf72",256:"#edcc61",
  512:"#edc850",1024:"#edc53f",2048:"#edc22e"
};

// initialize fixed 16 tiles
const grid = document.getElementById("grid");
let tiles = [];
for (let i=0;i<16;i++) {
  let div=document.createElement("div");
  div.className="tile";
  grid.appendChild(div);
  tiles.push(div);
}

function newGame(){
  board = Array.from({length:gridSize},()=>Array(gridSize).fill(0));
  score = 0; history = [];
  addRandomTile(); addRandomTile();
  updateGrid(); saveBest();
  hideOverlay();
}

function undo(){
  if (history.length){
    let prev = history.pop();
    board = prev.board;
    score = prev.score;
    updateGrid();
  }
}

function resetBest(){
  localStorage.removeItem("best2048");
  best=0; updateGrid();
}

function addRandomTile(){
  let empty=[];
  for(let r=0;r<gridSize;r++)
    for(let c=0;c<gridSize;c++)
      if(board[r][c]===0) empty.push([r,c]);
  if(empty.length){
    let [r,c]=empty[Math.floor(Math.random()*empty.length)];
    board[r][c]=Math.random()<0.9?2:4;
    markAnimation(r,c,"new");
  }
}

function markAnimation(r,c,type){
  let idx=r*gridSize+c;
  tiles[idx].classList.add(type);
  setTimeout(()=>tiles[idx].classList.remove(type),300);
}

function updateGrid(){
  let flat = board.flat();
  for(let i=0;i<16;i++){
    let val=flat[i];
    let tile=tiles[i];
    tile.textContent = val?val:"";
    tile.style.background = colors[val]||"#3c3a32";
    tile.style.color = val<=4?"#776e65":"#f9f6f2";
  }
  document.getElementById("score").textContent=score;
  best=Math.max(best,score,localStorage.getItem("best2048")||0);
  document.getElementById("best").textContent=best;
  localStorage.setItem("best2048",best);
}

function cloneBoard(b){ return b.map(r=>r.slice()); }

function move(dir){
  history.push({board:cloneBoard(board),score});
  let moved=false;
  function slide(row,rIndex){
    row=row.filter(v=>v);
    for(let i=0;i<row.length-1;i++){
      if(row[i]===row[i+1]){
        row[i]*=2; score+=row[i]; row[i+1]=0;
        markAnimation(rIndex,i,"merge");
      }
    }
    row=row.filter(v=>v);
    while(row.length<gridSize) row.push(0);
    return row;
  }
  for(let i=0;i<gridSize;i++){
    let row;
    if(dir==="left"){ row=slide(board[i],i); if(row.toString()!=board[i].toString()){moved=true;} board[i]=row; }
    if(dir==="right"){ row=slide(board[i].slice().reverse(),i).reverse(); if(row.toString()!=board[i].toString()){moved=true;} board[i]=row; }
    if(dir==="up"){ row=slide(board.map(r=>r[i]),i); if(row.toString()!=board.map(r=>r[i]).toString()){moved=true;} for(let r=0;r<gridSize;r++) board[r][i]=row[r]; }
    if(dir==="down"){ row=slide(board.map(r=>r[i]).reverse(),i).reverse(); if(row.toString()!=board.map(r=>r[i]).toString()){moved=true;} for(let r=0;r<gridSize;r++) board[r][i]=row[r]; }
  }
  if(moved){ addRandomTile(); updateGrid(); checkGame(); }
}

function isGameOver(){
  if(board.flat().includes(0)) return false;
  for(let r=0;r<gridSize;r++)
    for(let c=0;c<gridSize;c++){
      let v=board[r][c];
      if((c<gridSize-1 && v===board[r][c+1]) ||
         (r<gridSize-1 && v===board[r+1][c])) return false;
    }
  return true;
}

function checkGame(){
  if(board.flat().includes(2048)){
    showOverlay("ðŸŽ‰ You made 2048! Keep going...");
  }
  if(isGameOver()){
    showOverlay("Game Over! Final Score: "+score);
  }
}

function showOverlay(msg){
  let overlay=document.getElementById("overlay");
  document.getElementById("overlay-text").textContent=msg;
  overlay.style.display="flex";
}
function hideOverlay(){
  document.getElementById("overlay").style.display="none";
}

// AI autoplay
function autoPlay(){
  autoplay=!autoplay;
  if(autoplay) stepAI();
}
function stepAI(){
  if(!autoplay) return;
  let moveDir = bestMove();
  if(moveDir) move(moveDir);
  setTimeout(stepAI,200);
}
function bestMove(){
  let moves=["left","right","up","down"], best=null, bestVal=-Infinity;
  for(let m of moves){
    let copy=cloneBoard(board);
    if(simulateMove(copy,m)){
      let val=evaluate(copy);
      if(val>bestVal){ bestVal=val; best=m; }
    }
  }
  return best;
}
function simulateMove(b,dir){
  let moved=false;
  function slide(row){
    row=row.filter(v=>v);
    for(let i=0;i<row.length-1;i++){
      if(row[i]===row[i+1]){ row[i]*=2; row[i+1]=0; }
    }
    row=row.filter(v=>v);
    while(row.length<gridSize) row.push(0);
    return row;
  }
  for(let i=0;i<gridSize;i++){
    let row;
    if(dir==="left"){ row=slide(b[i]); if(row.toString()!=b[i].toString()){moved=true;} b[i]=row; }
    if(dir==="right"){ row=slide(b[i].slice().reverse()).reverse(); if(row.toString()!=b[i].toString()){moved=true;} b[i]=row; }
    if(dir==="up"){ row=slide(b.map(r=>r[i])); if(row.toString()!=b.map(r=>r[i]).toString()){moved=true;} for(let r=0;r<gridSize;r++) b[r][i]=row[r]; }
    if(dir==="down"){ row=slide(b.map(r=>r[i]).reverse()).reverse(); if(row.toString()!=b.map(r=>r[i]).toString()){moved=true;} for(let r=0;r<gridSize;r++) b[r][i]=row[r]; }
  }
  return moved;
}
function evaluate(b){
  // heuristic: empty cells + smoothness + max tile in corner
  let empty=b.flat().filter(v=>v===0).length;
  let max=Math.max(...b.flat());
  let smooth=0;
  for(let r=0;r<gridSize;r++) for(let c=0;c<gridSize-1;c++) smooth-=Math.abs(b[r][c]-b[r][c+1]);
  for(let c=0;c<gridSize;c++) for(let r=0;r<gridSize-1;r++) smooth-=Math.abs(b[r][c]-b[r+1][c]);
  let corner=b[0][0]===max||b[0][3]===max||b[3][0]===max||b[3][3]===max?1000:0;
  return empty*500 + smooth + corner + max;
}

// Keyboard
document.addEventListener("keydown",e=>{
  if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)){
    e.preventDefault();
    if(e.key==="ArrowLeft") move("left");
    if(e.key==="ArrowRight") move("right");
    if(e.key==="ArrowUp") move("up");
    if(e.key==="ArrowDown") move("down");
  }
});

// Touch controls
let startX, startY;
document.addEventListener("touchstart",e=>{
  startX=e.touches[0].clientX; startY=e.touches[0].clientY;
});
document.addEventListener("touchend",e=>{
  let dx=e.changedTouches[0].clientX-startX;
  let dy=e.changedTouches[0].clientY-startY;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>50) move("right");
    if(dx<-50) move("left");
  } else {
    if(dy>50) move("down");
    if(dy<-50) move("up");
  }
});

// Dark mode toggle
function toggleDark(){
  dark=!dark;
  document.body.classList.toggle("dark",dark);
  localStorage.setItem("dark2048",dark?"1":"0");
}

// Restore dark mode preference
if(localStorage.getItem("dark2048")==="1"){ toggleDark(); }

newGame();
</script>
</body>
</html>
